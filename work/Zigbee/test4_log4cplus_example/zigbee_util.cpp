#include "zigbee.h"



#ifdef _DEBUG

#ifdef PLUG
#define LOGSIZE 10*1024*1024
#else
#define LOGSIZE 512*1024
#endif

#define DBG_INIT() do { 		\
				log4cplus::SharedAppenderPtr dbgAppender(new log4cplus::RollingFileAppender("/tmp/zigwayLog1-"ZIGBEE_VERSION".log", LOGSIZE, 1));		\
				dbgAppender->setName("zigwayLog1Appender"); 					\
				std::string pattern = "%d{%m/%d/%y %H:%M:%S} [%t] - %m";			\
				std::auto_ptr<log4cplus::Layout> layout(new log4cplus::PatternLayout(pattern)); 	\
				dbgAppender->setLayout( layout );								\
				dbgLogger.reset( new log4cplus::Logger(log4cplus::Logger::getInstance("zigwayLogger1")) );	\
				dbgLogger->addAppender(dbgAppender);								\
				dbgLogger->setLogLevel(log4cplus::ALL_LOG_LEVEL);	\
				\
				log4cplus::SharedAppenderPtr dbgAppender2(new log4cplus::RollingFileAppender("/tmp/zigwayLog2-"ZIGBEE_VERSION".log", 512*1024, 1)); 	\
				dbgAppender2->setName("zigwayLog1Appender2");			\
				std::string pattern2 = "%m";			\
				std::auto_ptr<log4cplus::Layout> layout2(new log4cplus::PatternLayout(pattern2));		\
				dbgAppender2->setLayout( layout2 ); 							\
				dbgLogger2.reset( new log4cplus::Logger(log4cplus::Logger::getInstance("zigwayLogger2")) ); \
				dbgLogger2->addAppender(dbgAppender2);								\
				dbgLogger2->setLogLevel(log4cplus::ALL_LOG_LEVEL);	\
			} while(0)	


char 			dbgbuf[1024];
char 			dbgbuf2[1024];
std::auto_ptr<log4cplus::Logger> 		dbgLogger;
std::auto_ptr<log4cplus::Logger> 		dbgLogger2;
#endif


int zigbee_fd;
std::auto_ptr<ZigbeeDevice> thisDev;
//ZigbeeDevice 						thisDev;
// device list
ZigbeeDeviceList 					zigbeeDevList;
// devices found by atdump 2, but we still have to make sure whether they're connectable
PtrList<ZigbeeDevicePtr> 			zigbeeDevCandListForNewJoin;
ThreadSafePtrList<ZigbeeDevicePtr> 	zigbeeDevCandListForUpdate;
//ThreadSafeSet<uint16>				updateRecord;


// event handler func
ZigbeeEventCallback eventHandler = NULL;

/* static global vars */
// thread id of working routine
static pthread_t                    routine_tid = 0;
// control the routine thread, initialized in zigbee_init()
static volatile uint8               running;
// at command callback table, for zigbee_at_cmd
static AtCmdCallbackTable           atCmdCallbackTable;
// at command callback list, for receiving any incomming notification
static AtCmdCallbackList            atCmdCallbackList;
// at command callback global pointer, for only one at command can be run at one time
static AtCmdCallbackPtr    			atCmdSyncCallbackPtr;

// General callback pernament list, for dealing with notifications generated by the device
static GeneralCallbackList      	genCbList;
static GeneralCallbackSafeList		broadcastCbList;
// General callback temporary list, for dealing responses of the zcl or zdp request
// the processor of callback will call its find_remove() to get a match cb.
// and if this cb isn't sync, the processor will delete it after job is done.
static GeneralCallbackSafeList      genCbTmpList;

// devices always send 2 feedbacks on broadcast request
//static std::set<uint16>		updateDevListRecord;


/* functions for debugging */
#ifdef _DEBUG 
void printAddr( const Address_t *addr )
{
	if( addr->type == EXTENDED )
		pr_mem( addr->addrData.ieeeAddr, 8 );
	else
		DBG( "%04x", addr->addrData.shortAddr );
}

static
void printDevList()
{
	DBG( "Now zigbeeDevList is: " );

	int i = 0;
	for( ZigbeeDeviceList::iterator it = zigbeeDevList.begin(); it != zigbeeDevList.end(); ++it ) {
		DBG( "Device %d:\n %s", ++i, (*it)->toString() );
	}

	DBG( "END zigbeeDevList." );	
}

#endif

//!! free cb data, normally it's the user who waiting for a callback's return to free its cbData
// mem, but once wait fail like timeout, the cb obj itself must free those mem in its destructor
// pass these function ptr to the CB obj by its setCbData()
//!! typname T must be a pointer.
template < typename T >
static void deleteCbData( void *vptr, bool isArray )
{
	T ptr = (T)vptr;

//	DBG( "deleteCbData called, %s", isArray ? "array" : "not array" );
	
	if( isArray )
		delete [] ptr;
	else
		delete ptr;
}

static inline
void freeRawCbData( void *vptr, bool )
{
	free(vptr);
}


inline
bool operator== ( const Address_t &lhs, const Address_t &rhs )
{
	if( lhs.type != rhs.type )
		return false;
	if( NOTPRESENT == lhs.type )
		return true;
	if( EXTENDED == lhs.type )
		return memcmp( lhs.addrData.ieeeAddr, rhs.addrData.ieeeAddr, 8 ) == 0;
	return lhs.addrData.shortAddr == rhs.addrData.shortAddr;
}

inline
bool operator!= ( const Address_t &lhs, const Address_t &rhs )
{
	return !(lhs == rhs);
}


//ssize_t tread(int fd, void *buf, size_t nbytes, unsigned int timout)
//{
//	int				nfds;
//	fd_set			readfds;
//	struct timeval	tv;

//	tv.tv_sec = timout;
//	tv.tv_usec = 0;
//	FD_ZERO(&readfds);
//	FD_SET(fd, &readfds);
//	nfds = select(fd+1, &readfds, NULL, NULL, &tv);
//	if (nfds <= 0) {
//		if (nfds == 0)
//			errno = ETIME;
//		return(-1);
//	}
//	return(read(fd, buf, nbytes));
//}

//ssize_t twrite(int fd, const void *buf, size_t nbytes, unsigned int timout)
//{
//	int				nfds;
//	fd_set			writefds;
//	struct timeval	tv;

//	tv.tv_sec = timout;
//	tv.tv_usec = 0;
//	FD_ZERO(&writefds);
//	FD_SET(fd, &writefds);
//	nfds = select(fd+1, &writefds, NULL, NULL, &tv);
//	if (nfds <= 0) {
//		if (nfds == 0)
//			errno = ETIME;
//		return(-1);
//	}
//	return(write(fd, buf, nbytes));
//}

ssize_t Read(int fd, void *vptr, size_t n)
{
	static char			buf[ZIGBEE_BUFLEN];
	static char			*pStart = buf;
	static char			*pEnd = buf;
	char				*ptr = (char*)vptr;
	ssize_t 			nRead;
	ssize_t				dataSize;

	dataSize = pEnd - pStart;
	
	if( dataSize > 0 ) {
		nRead = dataSize > n ? n : dataSize;
		memcpy( ptr, pStart, nRead );
		pStart += nRead;
		return nRead;
	} 
	
	pStart = pEnd = buf;
	nRead = read( fd, buf, ZIGBEE_BUFLEN );
	if( nRead <= 0 )
		return nRead;
	pEnd += nRead;	
	pr_mem2( buf, nRead );
	if( nRead > n )
		nRead = n;
	memcpy( ptr, pStart, nRead );
	pStart += nRead;

	return nRead;
}


ssize_t	readn(int fd, void *vptr, size_t n)
{
	size_t	nleft;
	ssize_t	nread;
	char	*ptr;

	ptr = (char*)vptr;
	nleft = n;
	while (nleft > 0) {
		if ( (nread = Read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				nread = 0;		/* and call read() again */
			else
				return(-1);
		} else if (nread == 0)
			break;				/* EOF */

		nleft -= nread;
		ptr   += nread;
	}

	return(n - nleft);		/* return >= 0 */
}

//ssize_t treadn(int fd, void *buf, size_t nbytes, unsigned int timout)
//{
//	size_t	nleft;
//	ssize_t	nread;

//	nleft = nbytes;
//	while (nleft > 0) {
//		if ((nread = tread(fd, buf, nleft, timout)) < 0) {
//			if (nleft == nbytes)
//				return(-1); /* error, return -1 */
//			else
//				break;      /* error, return amount read so far */
//		} else if (nread == 0) {
//			break;          /* EOF */
//		}
//		nleft -= nread;
////		buf += nread;
//        buf = (char*)buf + nread;
//	}
//	return(nbytes - nleft);      /* return >= 0 */
//}

//ssize_t writen(int fd, const void *ptr, size_t n)
//{
//	size_t		nleft;
//	ssize_t		nwritten;

//	nleft = n;
//	while (nleft > 0) {
//		if ((nwritten = write(fd, ptr, nleft)) < 0) {
//			if (nleft == n)
//				return(-1); /* error, return -1 */
//			else
//				break;      /* error, return amount written so far */
//		} else if (nwritten == 0) {
//			break;
//		}
//		nleft -= nwritten;
////		ptr   += nwritten;
//        ptr = (char*)ptr + nwritten;
//	}
//	return(n - nleft);      /* return >= 0 */
//}

ssize_t writen(int fd, const void *ptr, size_t n)
{
	static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
	size_t		nleft;
	ssize_t		nwritten;

	pthread_mutex_lock( &lock );
	nleft = n;
	while (nleft > 0) {
		if ((nwritten = write(fd, ptr, nleft)) < 0) {
			if (nleft == n)
				goto FAIL;
			else
				break;      /* error, return amount written so far */
		} else if (nwritten == 0) {
			break;
		}
		nleft -= nwritten;
        ptr = (char*)ptr + nwritten;
	}
	pthread_mutex_unlock( &lock );
	return(n - nleft);      /* return >= 0 */
FAIL:
	pthread_mutex_unlock( &lock );
	return -1;
}


// Non-Canonical not text based
//int open_zigbee_device( const char *dev_name, int baudrate )
//{
//	int fd;

//	fd = OpenSerial(fd, dev_name);
//	if( fd < 0 )
//		return fd;

//	if( InitSerial(fd,115200,0,8,1,'N') < 0 ) {
//		perror( "InitSerial error!" );
//		return -1;
//	}

//	zigbee_fd = fd;

//	return fd;
//}

static
char *read_a_word( int fd, char retval = 0 )
{	
	static char buf[64];
	char *ptr = buf;
	char data;

	while( readn( fd, &data, 1 ) == 1 ) {
		if( retval && data == retval )
			return (char*)retval;
		if( isspace(data) ) {
			if( ptr != buf ) {
				*ptr = 0;
				return buf;
			} // if ptr != buf
		} else
			*ptr++ = data;
	} // while

	return (char*)NULL;		// read error
}

//static
//char *read_a_line( int fd, char *buf )
//{
//	char *ptr = buf;
//	char data;

//	// skip leading spaces
//	do {
//		if( readn(fd, &data, 1) != 1 )
//			goto FAIL; 
//	} while( isspace(data) );
//	*ptr++ = data;

//	while( readn( fd, &data, 1 ) == 1 ) {
//		if( '\r' == data || '\n' == data ) {
//			*ptr = 0;
//			return buf;
//		} else
//			*ptr++ = data;
//	} // while

//FAIL:
//	return (char*)NULL;
//}

//static
//uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
//{
//  *buf++ = BREAK_UINT32( val, 0 );
//  *buf++ = BREAK_UINT32( val, 1 );
//  *buf++ = BREAK_UINT32( val, 2 );
//  *buf++ = BREAK_UINT32( val, 3 );

//  return buf;
//}


//static
//uint8 *parseZclData( uint8 dataType, void *attrData, uint8 *buf )
//{
//  uint8 *pStr;
//  uint16 len;

//  switch ( dataType )
//  {
//    case ZCL_DATATYPE_DATA8:
//    case ZCL_DATATYPE_BOOLEAN:
//    case ZCL_DATATYPE_BITMAP8:
//    case ZCL_DATATYPE_INT8:
//    case ZCL_DATATYPE_UINT8:
//    case ZCL_DATATYPE_ENUM8:
//      *buf++ = *((uint8 *)attrData);
//       break;

//    case ZCL_DATATYPE_DATA16:
//    case ZCL_DATATYPE_BITMAP16:
//    case ZCL_DATATYPE_UINT16:
//    case ZCL_DATATYPE_INT16:
//    case ZCL_DATATYPE_ENUM16:
//    case ZCL_DATATYPE_SEMI_PREC:
//    case ZCL_DATATYPE_CLUSTER_ID:
//    case ZCL_DATATYPE_ATTR_ID:
//      *buf++ = LO_UINT16( *((uint16*)attrData) );
//      *buf++ = HI_UINT16( *((uint16*)attrData) );
//      break;

//    case ZCL_DATATYPE_DATA24:
//    case ZCL_DATATYPE_BITMAP24:
//    case ZCL_DATATYPE_UINT24:
//    case ZCL_DATATYPE_INT24:
//      *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
//      *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
//      *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
//      break;

//    case ZCL_DATATYPE_DATA32:
//    case ZCL_DATATYPE_BITMAP32:
//    case ZCL_DATATYPE_UINT32:
//    case ZCL_DATATYPE_INT32:
//    case ZCL_DATATYPE_SINGLE_PREC:
//    case ZCL_DATATYPE_TOD:
//    case ZCL_DATATYPE_DATE:
//    case ZCL_DATATYPE_UTC:
//    case ZCL_DATATYPE_BAC_OID:
//      buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
//      break;

//    case ZCL_DATATYPE_UINT40:
//      pStr = (uint8*)attrData;
//      buf = (uint8*)memcpy( buf, pStr, 5 );
//      break;

//    case ZCL_DATATYPE_UINT48:
//      pStr = (uint8*)attrData;
//      buf = (uint8*)memcpy( buf, pStr, 6 );
//      break;

//    case ZCL_DATATYPE_IEEE_ADDR:
//      pStr = (uint8*)attrData;
//      buf = (uint8*)memcpy( buf, pStr, 8 );
//      break;

//    case ZCL_DATATYPE_CHAR_STR:
//    case ZCL_DATATYPE_OCTET_STR:
//      pStr = (uint8*)attrData;
//      len = *pStr;
//      buf = (uint8*)memcpy( buf, pStr, len+1 ); // Including length field
//      break;

//    case ZCL_DATATYPE_LONG_CHAR_STR:
//    case ZCL_DATATYPE_LONG_OCTET_STR:
//      pStr = (uint8*)attrData;
//      len = BUILD_UINT16( pStr[0], pStr[1] );
//      buf = (uint8*)memcpy( buf, pStr, len+2 ); // Including length field
//      break;

//    case ZCL_DATATYPE_128_BIT_SEC_KEY:
//      pStr = (uint8*)attrData;
//      buf = (uint8*)memcpy( buf, pStr, SEC_KEY_LEN );
//      break;

//    case ZCL_DATATYPE_NO_DATA:
//    case ZCL_DATATYPE_UNKNOWN:
//      // Fall through

//    default:
//      break;
//  }

//  return ( buf );
//}

//ZclBase *createZcl( uint16 clusterID )
//{
//	switch( clusterID ) {
//	case ZCL_CLUSTER_ID_GEN_ON_OFF:
//		return new ZclGenOnOff;
//	case ZCL_CLUSTER_ID_UBEC_POWERMETER:
//		return new ZclUbecPowerMeter;
//	}

//	return NULL;
//}

uint16 to_u16( const void *ptr )
{
	uint16 retval;
	memcpy( &retval, ptr, 2 );
	return retval;
}

uint32 to_u32( const void *ptr )
{
	uint32 retval;
	memcpy( &retval, ptr, 4 );
	return retval;
}

int16 to_16( const void *ptr )
{
	int16 retval;
	memcpy( &retval, ptr, 2 );
	return retval;
}


uint8 make_address( Address_t *addr, AddrType_t addrType, const void *data )
{
    uint8 len;

//	DBG( "make_address()" );
    
	memset( addr, 0, sizeof(*addr) );
	addr->type = addrType;
	if( NOTPRESENT == addrType )
		return 0;
    
	if( EXTENDED == addrType ) {
		memcpy( addr->addrData.ieeeAddr, data, 8 );
        len = 8;
	} else {
//		DBG( "short addr" );
//		pr_mem( data, 2 );
		addr->addrData.shortAddr = to_u16(data);
//		DBG( "addr->addrData.shortAddr = %04x", addr->addrData.shortAddr );
        len = 2;
	}
    
	return len;
}

static
uint8 get_checksum( uint8 *start, uint8 *end )
{
	uint8 checksum = 0;
	uint8 *p;
    
	for( p = start; p != end; ++p )
		checksum += *p;
	checksum &= 0xFF;
	checksum = 0xFF - checksum;
    
	return checksum;
}


// for add_new_device_by_mac()
struct RejoinDevFinder {
	RejoinDevFinder( const ZigbeeDevicePtr p ) : ptr(p) {}

	bool operator() ( const ZigbeeDevicePtr pDev ) const
	{
		if( pDev->addr() != ptr->addr() && memcmp(pDev->macAddr(), ptr->macAddr(), 8) == 0 )
			return true;
		return false;
	}

	const ZigbeeDevicePtr		ptr;
};


static
int add_new_device_by_mac( ZigbeeDevice *pDev )
{
	int										ret;
	ZDevFinder_t							finder;
	ZigbeeDevice							*pExist;

//	DBG( "add_new_device_by_mac()" );

	finder = ZDEV_FIND_BY_MAC;
	if( (pExist = zigbeeDevList.find_remove( RejoinDevFinder(pDev) )) ) {
		DBG( "add_new_device_by_mac() found leaving device: %s", pExist->toString() );
		if( eventHandler )
			eventHandler( ZIGBEE_LEAVE, pExist );
		delete pExist;
	} // if pExist

	ret = zigbeeDevList.add_unique_no_replace( pDev, ZDevCmp(finder, 0, pDev->macAddr()) );

#ifdef _DEBUG
	printDevList();
#endif

	return ret;
}


//!! specialized for ubec
static
uint16 getDeviceType( const char *devName )
{
    if( strcmp(devName, "PNI-Meter") == 0 )
        return ZCL_HA_DEVICEID_UBEC_PLUG;
    else if( strcmp(devName, "PNI-CO2") == 0 )
        return ZCL_HA_DEVICEID_UEBC_AIR_MONITOR;
    else if( strcmp(devName, "PNI-Plug") == 0 )
		return ZCL_HA_DEVICEID_UEBC_SIMPLE_PLUG;

    return ZCL_HA_DEVICEID_UNKNOWN;
}

static
int parseDevQueryInfo( void *arg, Callback *cb, bool queryMac )
{
    int                 ret = 0;
    ZigbeeDevice        *pDev;
    std::auto_ptr<ZigbeeDevice>       pSpecDev;
    uint16              devID;
//    ZclFrame            *pFrame = (ZclFrame*)arg;
	std::auto_ptr<ZclFrame> 	pFrame( (ZclFrame*)arg );
    const uint8         *pAttr1, *pAttr2;
    uint16              attrID, attrID1, attrID2;
    uint8               status;
    std::string         manu, model;
	ZDevFinder_t		finder;

	
    DBG( "parseDevQueryInfo() queryMac = %s", queryMac ? "true" : "false" );
		
//#ifdef _DEBUG
//	pFrame->print();
//#endif
    
    pAttr1 = pFrame->payload();
    if( !pAttr1 ) {
        ret = 1;
		goto RET;
	}
    attrID1 = to_u16( pAttr1 );
#ifdef HOST_ZCL_ENDIAN_DIFF
    BYTESWAP( &attrID1, uint16 );
#endif
    pAttr1 += 2;
    if( ZclGenBasic::MANUNAME == attrID1 )
        attrID2 = ZclGenBasic::MODELID;
    else if( ZclGenBasic::MODELID == attrID1 )
        attrID2 = ZclGenBasic::MANUNAME;
    else {
		DBG( "get first attr id error" );
        ret = 1;
		goto RET;
	}
    status = *pAttr1++;
    if( status ) {
		DBG( "Returned status fail." );
        ret = status;
		goto RET;
	}
	++pAttr1;			// skip data type
	if( !isprint(*pAttr1) )
		++pAttr1;
    
    // now locate attr2
    pAttr2 = pFrame->payload() + pFrame->payloadLen() - 2;
    while( pAttr2 > pAttr1 ) {
        attrID = to_u16( pAttr2 );
#ifdef HOST_ZCL_ENDIAN_DIFF
        BYTESWAP( &attrID, uint16 );
#endif
        if( attrID == attrID2 )
            break;
        --pAttr2;
    }
    
    if( pAttr2 <= pAttr1 ) {
		DBG( "get second attr error." );
        ret = 1;
		goto RET;
	}
    
    if( ZclGenBasic::MANUNAME == attrID1 )
        manu.assign( (char*)pAttr1, (char*)pAttr2 );
    else
        model.assign( (char*)pAttr1, (char*)pAttr2 );
    
    pAttr2 += 2;
    status = *pAttr2++;
    if( status ) {
		DBG( "Returned status fail." );
        ret = status;
		goto RET;
	}
	++pAttr2;		// skip data type
	if( !isprint(*pAttr2) )
		++pAttr2;
	
    if( ZclGenBasic::MANUNAME == attrID2 )
        manu.assign( (char*)pAttr2, (char*)(pFrame->payload() + pFrame->payloadLen()) );
    else
        model.assign( (char*)pAttr2, (char*)(pFrame->payload() + pFrame->payloadLen()) );
    
    manu.append( "-" ).append( model );
    DBG( "Received QueryInfo feedback from %s", manu.c_str() );
    
    //!! specialized for ubec
    devID = getDeviceType( manu.c_str() );
    switch( devID ) {
        case ZCL_HA_DEVICEID_UBEC_PLUG:
            pSpecDev.reset( new UbecPlug );
            break;
        case ZCL_HA_DEVICEID_UEBC_AIR_MONITOR:
            pSpecDev.reset( new UbecAirMonitor );
            break;
	case ZCL_HA_DEVICEID_UEBC_SIMPLE_PLUG:
	    pSpecDev.reset( new UbecSimplePlug );
	    break;
        default:
            ret = 2;
			goto RET;
    } // switch

	finder = (ZDevFinder_t)( ZDEV_FIND_BY_ADDR | ZDEV_FIND_BY_PROFILE | ZDEV_FIND_BY_ENDPOINT );
    pDev = zigbeeDevCandListForNewJoin.find_remove( ZDevCmp(finder, pFrame->addr(), NULL, NULL, pFrame->profileID(), pFrame->srcEp()) );
    if( !pDev ) {
		DBG( "Cannot find device in zigbeeDevCandListForNewJoin." );
        ret = 1;
		goto RET;
	}

//	DBG( "parseDevQueryInfo() got candidate device %s", pDev->toString() );
    
	pSpecDev->setMacAddr( pDev->macAddr() );
    delete pDev;
    pSpecDev->setName( manu.c_str() );
	pSpecDev->setEndpoint( pFrame->srcEp() );
	pSpecDev->setProfileId( pFrame->profileID() );
	pSpecDev->setAddr( pFrame->addr() );

//	DBG( "parseDevQueryInfo() trying to add new device: %s", pSpecDev->toString() );

	if( queryMac ) {
		pDev = pSpecDev.release();
		zigbeeDevCandListForNewJoin.add( pDev );
		pDev->queryMacAddr();
		ret = 0;
		goto RET;
	} // if

	if( add_new_device_by_mac( pSpecDev.get() ) == 0 ) {
		pDev = pSpecDev.release();
		if( eventHandler )
			ret = eventHandler( ZIGBEE_NEW_JOIN, pDev );
		else
			ret = 0;
	} // if add_new_device_by_mac
#ifdef _DEBUG
	else {
		DBG( "parseDevQueryInfo() Device already exists." );
	}
#endif

RET:
//	delete cb;    
    return ret;
}



int parseDevQueryInfoQueryMac( void *arg, Callback *cb )
{
	return parseDevQueryInfo(arg, cb, true);
}


int parseDevQueryInfoNoMac( void *arg, Callback *cb )
{
	return parseDevQueryInfo(arg, cb, false);
}



int parseUpdateDevList( void *arg, Callback *cb )
{
	int					ret = 0;
//	ZclFrame            *pFrame = (ZclFrame*)arg;
	std::auto_ptr<ZclFrame> 	pFrame( (ZclFrame*)arg );
    std::auto_ptr<ZigbeeDevice>       pSpecDev;
	ZigbeeDevice		*pDev;
    uint16              devID;
    const uint8         *pAttr1, *pAttr2;
    uint16              attrID, attrID1, attrID2;
    uint8               status;
    std::string         manu, model;	
	ZDevFinder_t		finder;


	DBG( "parseUpdateDevList()" );

//	if( updateRecord.insert( pFrame->addr() ).second == false ) {
//		DBG( "Device %04x already handled.", pFrame->addr() );
//		ret = 0;
//		goto RET;
//	}

    pAttr1 = pFrame->payload();
    if( !pAttr1 ) {
        ret = 1;
		goto RET;
	}
    attrID1 = to_u16( pAttr1 );
#ifdef HOST_ZCL_ENDIAN_DIFF
    BYTESWAP( &attrID1, uint16 );
#endif
    pAttr1 += 2;
    if( ZclGenBasic::MANUNAME == attrID1 )
        attrID2 = ZclGenBasic::MODELID;
    else if( ZclGenBasic::MODELID == attrID1 )
        attrID2 = ZclGenBasic::MANUNAME;
    else {
		DBG( "get first attr id error" );
        ret = 1;
		goto RET;
	}
    status = *pAttr1++;
    if( status ) {
		DBG( "Returned status fail." );
        ret = status;
		goto RET;
	}
	++pAttr1;			// skip data type
	if( !isprint(*pAttr1) )
		++pAttr1;
    
    // now locate attr2
    pAttr2 = pFrame->payload() + pFrame->payloadLen() - 2;
    while( pAttr2 > pAttr1 ) {
        attrID = to_u16( pAttr2 );
#ifdef HOST_ZCL_ENDIAN_DIFF
        BYTESWAP( &attrID, uint16 );
#endif
        if( attrID == attrID2 )
            break;
        --pAttr2;
    }
    
    if( pAttr2 <= pAttr1 ) {
		DBG( "get second attr error." );
        ret = 1;
		goto RET;
	}
    
    if( ZclGenBasic::MANUNAME == attrID1 )
        manu.assign( (char*)pAttr1, (char*)pAttr2 );
    else
        model.assign( (char*)pAttr1, (char*)pAttr2 );
    
    pAttr2 += 2;
    status = *pAttr2++;
    if( status ) {
		DBG( "Returned status fail." );
        ret = status;
		goto RET;
	}
	++pAttr2;		// skip data type
	if( !isprint(*pAttr2) )
		++pAttr2;
	
    if( ZclGenBasic::MANUNAME == attrID2 )
        manu.assign( (char*)pAttr2, (char*)(pFrame->payload() + pFrame->payloadLen()) );
    else
        model.assign( (char*)pAttr2, (char*)(pFrame->payload() + pFrame->payloadLen()) );
    
    manu.append( "-" ).append( model );
    DBG( "Received Update Device feedback from %s", manu.c_str() );
    
    //!! specialized for ubec
    devID = getDeviceType( manu.c_str() );
    switch( devID ) {
        case ZCL_HA_DEVICEID_UBEC_PLUG:
            pSpecDev.reset( new UbecPlug );
            break;
        case ZCL_HA_DEVICEID_UEBC_AIR_MONITOR:
            pSpecDev.reset( new UbecAirMonitor );
            break;
        case ZCL_HA_DEVICEID_UEBC_SIMPLE_PLUG:
            pSpecDev.reset( new UbecSimplePlug );
            break;
        default:
            ret = 2;
			goto RET;
	} // switch

	pSpecDev->setName( manu.c_str() );
//	pSpecDev->setEndpoint( pFrame->srcEp() );		//!! 0xFF
	pSpecDev->setProfileId( pFrame->profileID() );
	pSpecDev->setAddr( pFrame->addr() );

	finder = ZDEV_FIND_BY_ADDR;

	pDev = pSpecDev.get();
	delete zigbeeDevCandListForUpdate.add_unique_replace( pSpecDev.release(), ZDevCmp(finder, pDev->addr()) );

	ret = pDev->queryMacAddr();
	

//	if( zigbeeDevList.add_unique_no_replace( pSpecDev.get(), ZDevCmp(finder, pSpecDev->addr(), NULL, 
//					pSpecDev->name(), pFrame->profileID()) ) == 0 ) {
//		pSpecDev.release();
//		ret = 0;
//	} else {
//		DBG( "Device already exists" );
//		ret = 3;
//	}

	// check whether exists
//	if( zigbeeDevList.find( ZDevCmp(finder, pSpecDev->addr(), NULL, pSpecDev->name(), pFrame->profileID()) ) ) {
//		DBG( "Device already exists." );
//		ret = 3;
//		goto RET;		
//	}

//	if( eventHandler ) {
//		if( eventHandler( ZIGBEE_NEW_JOIN, pSpecDev.get() ) )
//			goto RET;
//	} // if ( eventHandler )
//	
//	zigbeeDevList.add( pSpecDev.release() );
	
RET:
	broadcastCbList.add( GeneralCallbackPtr(dynamic_cast<GeneralCallback*>(cb)) );	// for the succeeding work
	DBG( "parseUpdateDevList() terminates with retcode %d", ret );
	return ret;
}





#if 0
int parseUpdateDevList( void *arg, Callback *cb )
{
	int					ret = 0;
//	ZclFrame            *pFrame = (ZclFrame*)arg;
	std::auto_ptr<ZclFrame> 	pFrame( (ZclFrame*)arg );
    std::auto_ptr<ZigbeeDevice>       pSpecDev;
    uint16              devID;
    const uint8         *pAttr1, *pAttr2;
    uint16              attrID, attrID1, attrID2;
    uint8               status;
    std::string         manu, model;	
	ZDevFinder_t		finder;


	DBG( "parseUpdateDevList()" );
//	if( updateDevListRecord.insert(pFrame->addr()).second == false ) {
//		DBG( "Device %04x already handled.", pFrame->addr() );
//		ret = 1;
//		goto RET;
//	}	

    pAttr1 = pFrame->payload();
    if( !pAttr1 ) {
        ret = 1;
		goto RET;
	}
    attrID1 = to_u16( pAttr1 );
#ifdef HOST_ZCL_ENDIAN_DIFF
    BYTESWAP( &attrID1, uint16 );
#endif
    pAttr1 += 2;
    if( ZclGenBasic::MANUNAME == attrID1 )
        attrID2 = ZclGenBasic::MODELID;
    else if( ZclGenBasic::MODELID == attrID1 )
        attrID2 = ZclGenBasic::MANUNAME;
    else {
		DBG( "get first attr id error" );
        ret = 1;
		goto RET;
	}
    status = *pAttr1++;
    if( status ) {
		DBG( "Returned status fail." );
        ret = status;
		goto RET;
	}
	++pAttr1;			// skip data type
	if( !isprint(*pAttr1) )
		++pAttr1;
    
    // now locate attr2
    pAttr2 = pFrame->payload() + pFrame->payloadLen() - 2;
    while( pAttr2 > pAttr1 ) {
        attrID = to_u16( pAttr2 );
#ifdef HOST_ZCL_ENDIAN_DIFF
        BYTESWAP( &attrID, uint16 );
#endif
        if( attrID == attrID2 )
            break;
        --pAttr2;
    }
    
    if( pAttr2 <= pAttr1 ) {
		DBG( "get second attr error." );
        ret = 1;
		goto RET;
	}
    
    if( ZclGenBasic::MANUNAME == attrID1 )
        manu.assign( (char*)pAttr1, (char*)pAttr2 );
    else
        model.assign( (char*)pAttr1, (char*)pAttr2 );
    
    pAttr2 += 2;
    status = *pAttr2++;
    if( status ) {
		DBG( "Returned status fail." );
        ret = status;
		goto RET;
	}
	++pAttr2;		// skip data type
	if( !isprint(*pAttr2) )
		++pAttr2;
	
    if( ZclGenBasic::MANUNAME == attrID2 )
        manu.assign( (char*)pAttr2, (char*)(pFrame->payload() + pFrame->payloadLen()) );
    else
        model.assign( (char*)pAttr2, (char*)(pFrame->payload() + pFrame->payloadLen()) );
    
    manu.append( "-" ).append( model );
    DBG( "Received Query Device feedback from %s", manu.c_str() );
    
    //!! specialized for ubec
    devID = getDeviceType( manu.c_str() );
    switch( devID ) {
        case ZCL_HA_DEVICEID_UBEC_PLUG:
            pSpecDev.reset( new UbecPlug );
            break;
        case ZCL_HA_DEVICEID_UEBC_AIR_MONITOR:
            pSpecDev.reset( new UbecAirMonitor );
            break;
        case ZCL_HA_DEVICEID_UEBC_SIMPLE_PLUG:
            pSpecDev.reset( new UbecSimplePlug );
            break;
        default:
            ret = 2;
			goto RET;
	} // switch

	pSpecDev->setName( manu.c_str() );
//	pSpecDev->setEndpoint( pFrame->srcEp() );		//!! 0xFF
	pSpecDev->setProfileId( pFrame->profileID() );
	pSpecDev->setAddr( pFrame->addr() );

	//!! should by endpoint, but Ubec devices always return 0xFF as response to broadcast
	finder = (ZDevFinder_t)( ZDEV_FIND_BY_ADDR | ZDEV_FIND_BY_NAME | ZDEV_FIND_BY_PROFILE );

	if( zigbeeDevList.add_unique_no_replace( pSpecDev.get(), ZDevCmp(finder, pSpecDev->addr(), NULL, 
					pSpecDev->name(), pFrame->profileID()) ) == 0 ) {
		pSpecDev.release();
		ret = 0;
	} else {
		DBG( "Device already exists" );
		ret = 3;
	}

	// check whether exists
//	if( zigbeeDevList.find( ZDevCmp(finder, pSpecDev->addr(), NULL, pSpecDev->name(), pFrame->profileID()) ) ) {
//		DBG( "Device already exists." );
//		ret = 3;
//		goto RET;		
//	}

//	if( eventHandler ) {
//		if( eventHandler( ZIGBEE_NEW_JOIN, pSpecDev.get() ) )
//			goto RET;
//	} // if ( eventHandler )
//	
//	zigbeeDevList.add( pSpecDev.release() );
	
RET:
	broadcastCbList.add( dynamic_cast<GeneralCallbackPtr>(cb) );	// for the succeeding work
	DBG( "parseUpdateDevList() terminates with retcode %d", ret );
	return ret;
}
#endif // 0



//static
//int parseAtDump( void *arg, Callback *cb )
//{
//	char				*word;
//	uint16				panID;
//	ZigbeeDevicePtr		pDev = 0;

//	DBG( "parseAtDump Called." );

//	do {
//		if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//			goto FAIL;

//		if( strcmp(word, "PanID") == 0 ) {
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			panID = (uint16)strtol( word, NULL, 16 );
//			if( panID != thisDev.panId() )
//				continue;
//			else {
//				if( pDev )
//					zigbeeDevList.add( pDev );
//				pDev = new ZigbeeDevice;
//			}
//		} // panid

//		if( strcmp(word, "MAC") == 0 ) {
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			if( strcmp(word, "Addr") != 0 )
//				continue;
//			// mac addr data
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			pDev->setMacAddr( word );			
//		} // mac addr

//		if( strcmp(word, "NetworkAddress") == 0 ) {
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			pDev->setAddr( (uint16)strtol( word, NULL, 16 ) );
//		}

//		if( strcmp(word, "DeviceType") == 0 ) {
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			pDev->setRole( strtol( word, NULL, 16 ) );
//		}

//		if( strcmp(word, "LogicalChannel") == 0 ) {
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			pDev->setChannel( (uint8)strtol( word, NULL, 16 ) );
//		}		

//		if( strcmp(word, "Security") == 0 ) {
//			if( (word = read_a_word( zigbee_fd, readbuf )) == NULL )
//				goto FAIL;
//			pDev->setSecurity( (uint8)strtol( word, NULL, 16 ) );
//		}		
//	} while( strcmp(word, "OK") != 0 );

//	if( pDev )
//		zigbeeDevList.add( pDev );	

//	if( cb )
//		cb->finish( Callback::SUCCESS, 0 );
//	return 0;
//FAIL:
//	DBG( "parseAtDump fail." );
//	if( cb )
//		cb->finish( Callback::FAIL, -1 );	
//	delete pDev;
//	return -1;
//}

static
int parseNewJoin( void *arg, Callback *cb )
{
	int					i;
	char				*word;
    ZigbeeDevice        *pDev;
    uint16              addrData;

	DBG( "parseNewJoin Called." );
    pDev = new ZigbeeDevice;

	// 2 fields, long short addr
	for( i = 1; i <= 2; ++i ) {
		word = read_a_word( zigbee_fd );
		if( !word )
			goto FAIL;	
		switch(i) {
		case 1:
			DBG( "parseNewJoin, Mac Addr: %s", word );
            pDev->setMacAddr( word );
			break;
		case 2:
			DBG( "parseNewJoin, Short Addr: %s", word );
            addrData = (uint16)strtol( word, NULL, 16 );
            pDev->setAddr( addrData );
			break;
		} // switch
	} // for

	DBG( "parseNewJoin() found candidate device: %s", pDev->toString() );
    
    delete zigbeeDevCandListForNewJoin.add_unique_replace( pDev, ZDevCmp(ZDEV_FIND_BY_ADDR, pDev->addr(), NULL) );

	// to avoid joining - sending data conflict
	usleep(300 * 1000);
    pDev->queryInfo();

	return 0;
FAIL:
    delete pDev;
	return -1;
}



static
int parseAtIeee( void *arg, Callback *cb )
{
	char									*word;
	char									macAddr[17];
	uint16									nwkAddr;
	std::auto_ptr<ZigbeeDevice>				pDev;
	ZDevFinder_t							finder;
	bool									sendNewJoin = false;

	DBG( "parseAtIeee()" );

	if( (word = read_a_word( zigbee_fd )) == NULL )
		goto FAIL;
	strncpy( macAddr, word, 17 );
	if( (word = read_a_word( zigbee_fd )) == NULL )
		goto FAIL;
	nwkAddr = (uint16)strtol(word, NULL, 16);
	
	finder = ZDEV_FIND_BY_ADDR;
	pDev.reset( zigbeeDevCandListForUpdate.find_remove( ZDevCmp(finder, nwkAddr) ) );

	if( !(pDev.get()) ) {
		pDev.reset( zigbeeDevCandListForNewJoin.find_remove( ZDevCmp(finder, nwkAddr) ) );
		sendNewJoin = true;
	}
	
	if( !(pDev.get()) ) {
		DBG( "Cannot found device %04x in zigbeeDevCandListForUpdate" );
		goto FAIL;
	}

	pDev->setMacAddr( macAddr );

	DBG( "parseAtIeee() trying to add new device: %s", pDev->toString() );

	if( add_new_device_by_mac(pDev.get() ) == 0 ) {
		if( sendNewJoin && eventHandler )
			eventHandler( ZIGBEE_NEW_JOIN, pDev.get() );
		pDev.release();		
	}
#ifdef _DEBUG
	else {
		DBG( "Device already exists." );
	}
#endif

	if( cb )
		cb->finish( Callback::SUCCESS, 0 );	
	return 0;
FAIL:
	if( cb )
		cb->finish( Callback::FAIL, -1 );	
	return -1;
}


static
int parseAtInfo( void *arg, Callback *cb )
{
	char					*word;
	int						i, j, ret;
	uint8 					data, *pDst;
	std::auto_ptr<ZigbeeDevice> 	devInfo;
	char 					tmp[3], *pSrc;
	uint8					macAddr[8];

	DBG( "parseAtInfo" );

	devInfo.reset( new ZigbeeDevice );
	if( !devInfo.get() )
		goto FAIL;

	// totally 7 fields
	for( i = 1; i <= 7; ++i ) {
		word = read_a_word( zigbee_fd );
		if( !word )
			goto FAIL;
		switch(i) {
		case 1:
			devInfo->setChannel( (uint8)strtol( word, NULL, 16 ) );
			break;
		case 2:
			devInfo->setPanId( (uint16)strtol( word, NULL, 16 ) );
			break;
		case 3:	
			devInfo->setRole( (ZigbeeDevType_t)strtol( word, NULL, 16 ) );
			break;
		case 4:	
			devInfo->setAddr( (uint16)strtol( word, NULL, 16 ) );
			break;
		case 5:		// mac addr
			if( strlen(word) != 16 )
				goto FAIL;
//			pDst = macAddr;		
//			tmp[2] = 0;
//			for( j = 0, pSrc = word; j < 8; ++j, pSrc += 2 ) {
//				strncpy( tmp, pSrc, 2 );
//				data = (uint8)strtol(tmp, NULL, 16);
//				*pDst++ = data;
//			} // for
			devInfo->setMacAddr( word );
			break;
		case 6:
			devInfo->setP2pAddr( (uint16)strtol( word, NULL, 16 ) );
			break;
		case 7:
			devInfo->setSecurity( (uint8)strtol( word, NULL, 16 ) );
			break;
		} // switch
	} // for

	if( cb ) {
		cb->setCbData( devInfo.release(), deleteCbData<ZigbeeDevice*> );
		cb->finish( Callback::SUCCESS, 0 );
	}
	return 0;
FAIL:
	DBG( "parseAtInfo fail." );
	if( cb )
		cb->finish( Callback::FAIL, -1 );
	return -1;
}



static
int parseAtCmdRsp( const char *cmdStr )
{
	AtCmdCallbackPtr ptr;
	int ret;
	
//	DBG( "parseAtCmdRsp %s", cmdStr );

//#ifdef _DEBUG
//	if( atCmdSyncCallbackPtr )
//		DBG( "atCmdSyncCallbackPtr NAME = %s", atCmdSyncCallbackPtr->name() );
//	else
//		DBG( "atCmdSyncCallbackPtr is NULL" );
//#endif

	if( atCmdSyncCallbackPtr.get() && strcmp(atCmdSyncCallbackPtr->name(), cmdStr) == 0 ) {
		ptr = atCmdSyncCallbackPtr;
	} else {
		// this list now temporarily unavailable
		for( AtCmdCallbackList::iterator it = atCmdCallbackList.begin(); 
				it != atCmdCallbackList.end(); ++it ) {
			if( strcmp(cmdStr, (*it)->name()) == 0 ) {
				ptr = *it;
				break;
			} // if
		} // for
	} // if

	if( !ptr.get() ) {
//		DBG( "No callback processor found." );
		return -1;
	}

	CallbackProcessorFunc funcPtr = ptr->routinePtr();
	if( funcPtr )
		ret = funcPtr( NULL, ptr.get() );

	if( ret ) {
		DBG( "callback processor fail, %d", ret );
		return ret;
	}
	
	return 0;
}

static
int buildZclFrame( ZclFrame &frame, const uint8 *start, const uint8 *end )
{
	const uint8 		*ptr = start;
	uint16				manuCode;

	frame.setCtrl( *ptr++ );
	
	if( frame.isManuSpec() ) {
		manuCode = to_u16( ptr );
		ptr += 2;
#ifdef HOST_ZCL_ENDIAN_DIFF
		BYTESWAP( &manuCode, uint16 );
#endif
		frame.setManuCode( manuCode );
	} // if

	frame.setSeqNO( *ptr++ );
	frame.setCmd( *ptr++ );
	frame.setPayload( ptr, end );	

	return (end - start);
}

static
int handleAutoReport( void *arg, Callback *cb )
{
	uint16			attrID;
	Address_t		addr;
	uint16 			addrData;
	ZclFrame 		reqFrame;
	std::auto_ptr<ZclFrame> 	pFrame( (ZclFrame*)arg );
	ZigbeeDevice        *pDev;
	ZDevFinder_t		finder = (ZDevFinder_t)( ZDEV_FIND_BY_ADDR | ZDEV_FIND_BY_PROFILE | ZDEV_FIND_BY_ENDPOINT );
	int					ret;

	DBG( "handleAutoReport()" );

	if( !(pFrame->payload()) )
		return 1;

	addrData = pFrame->addr();
	make_address( &addr, SHORT, &addrData );

	// first disable auto reporting of this device
	attrID = to_u16( pFrame->payload() );
	reqFrame.setSeqNO( SEQNO_CONFIG_REPORT );
	reqFrame.setCmd( 0x06 );	
	reqFrame.appendPayload( 0x01 );		// direction
	reqFrame.appendPayload( &attrID, 2 );
	reqFrame.appendPayload( 0x0 );
	reqFrame.appendPayload( 0x0 );		// timeout

	ret = zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0x0, ZCL_HA_PROFILE_ID, ZCL_CLUSTER_ID_GEN_BASIC,
                         &reqFrame, 0 );

	if( ret ) {
		DBG( "handleAutoReport() send cmd fail." );
		return ret;
	}


	// then add new device
//	DBG( "handleAutoReport trying to add new device." );
	pDev = zigbeeDevList.find( ZDevCmp(finder, pFrame->addr(), NULL, NULL, pFrame->profileID(), pFrame->srcEp()) );
//	DBG( "find finish." );
	if( pDev ) {
		DBG( "Device already exists" );
		return 0;
	}
//	DBG( "Now add new dev to devList." );

	pDev = new ZigbeeDevice;
	if( !pDev )
		return -1;
	pDev->setAddr( addrData );
	pDev->setProfileId( pFrame->profileID() );
	pDev->setEndpoint( pFrame->srcEp() );
	delete zigbeeDevCandListForNewJoin.add_unique_replace( pDev, ZDevCmp(finder, pDev->addr(), NULL, NULL, pFrame->profileID(), pFrame->srcEp()) );

	return pDev->queryInfo( true );
}



static
int handleAlarmHelper( ZigbeeDevice *pDev, void *warningMsg )
{
	DBG( "handleAlarmHelper" );
	return pDev->processWarning( (uint8*)warningMsg );
}

static
int handleAlarm( void *arg, Callback *cb )
{
	std::auto_ptr<ZclFrame> 	pFrame( (ZclFrame*)arg );
	ZDevFinder_t				finder = (ZDevFinder_t)( ZDEV_FIND_BY_ADDR | ZDEV_FIND_BY_PROFILE | ZDEV_FIND_BY_ENDPOINT );

	DBG( "handleAlarm invoked..." );

	return zigbeeDevList.find_op( ZDevCmp(finder, pFrame->addr(), NULL, NULL, pFrame->profileID(), pFrame->srcEp()), 
				handleAlarmHelper, (void*)(pFrame->payload()) );
}



//!! Universal zcl callback processor
static
int parseZclCB( void *arg, Callback *cb )
{
	std::auto_ptr<ZclFrame> 	pFrame( (ZclFrame*)arg );

	DBG( "parseZclCB: " );
//#ifdef _DEBUG
//	printZclFrame( *pFrame );
//#endif

	if( cb ) {
		if( !(cb->getWaitFlag()) ) {
			DBG( "non waiting zcl callback." );
//			delete cb;
		} else {		
			cb->setCbData( pFrame.release(), deleteCbData<ZclFrame*> );
			cb->finish( Callback::SUCCESS, 0 );
		} // if cb waitflag
	} // if cb
		
	return 0;
}

static
int parseGenRsp()
{
	static uint8	buf[ZIGBEE_BUFLEN];
	int				ret = 0;
	uint16			length;
	Address_t		addr;
	AddrType_t		addrType;
    uint8           addrLen;
	uint8			cmd;
	uint8 			*ptr = buf;
	uint8			*pRead;
	uint8			srcep, dstep;
	uint16			profileID, clusterID;
	std::auto_ptr<ZclFrame> 	pFrame;
	GeneralCallbackPtr 		pcb;
	ZigbeeCmpType_t			cmpMethod;

	DBG( "\nparseGenRsp()" );

	// read length, buf start with "length"
	if( readn( zigbee_fd, ptr, 2 ) != 2 ) {
		DBG( "parseRawDRsp read error, %s", strerror(errno) );
		return -1;
	}
	ptr += 2;

	length = to_u16(buf);
#ifdef HOST_ZDEV_ENDIAN_DIFF
	BYTESWAP( &length, uint16 );
#endif
//	DBG( "length = %04x", length );

	//!! I'm not sure the max len of ubec serial frame
	if( length > ZIGBEE_BUFLEN ) {
		DBG( "Invalid length: %u", length );
		return 1;
	}

	// read the rest length + 2 bytes of the frame
	if( readn( zigbee_fd, ptr, length+2 ) != length+2 ) {
		DBG( "parseRawDRsp read frame error, %s", strerror(errno) );
		return -1;
	}
	ptr += length + 1; // point to the End byte
	if( *ptr != 0x03 ) {
		DBG( "Invalid EOF, %02x", *ptr );
		return 2;
	}

	// checksum
	--ptr;
	if( *ptr != get_checksum(buf, ptr) ) {
		DBG( "check sum fail." );
		return 3;
	}

	cmd = buf[2];		// buf start with "length"
//	DBG( "cmd = %02x", cmd );

	// address
	addrType = (AddrType_t)( (cmd >> 6) & 0x03 );
	addrLen = make_address( &addr, addrType, buf + 3 );
//	DBG( "address buf:" );
//	pr_mem( buf+3, 2 );
//	DBG( "Address = %04x", addr.addrData.shortAddr );
#ifdef HOST_ZDEV_ENDIAN_DIFF
	if( addr.type != EXTENDED )
		BYTESWAP( &(addr.addrData.shortAddr), uint16 );
#endif
//	DBG( "Address = %04x", addr.addrData.shortAddr );
	pRead = buf + 3 + addrLen;		// start of the data (req)
	// cmd type
	if( (cmd & API_RAW) == API_RAW ) {
		// read data req
		srcep = *pRead++;
		dstep = *pRead++;
//		DBG( "srcep = %02x, dstep = %02x", srcep, dstep );
		profileID = to_u16(pRead);
#ifdef HOST_ZDEV_ENDIAN_DIFF
		BYTESWAP( &profileID, uint16 );
#endif
//		DBG( "profileID = %04x", profileID );
		pRead += 2;
		clusterID = to_u16(pRead);
#ifdef HOST_ZDEV_ENDIAN_DIFF
		BYTESWAP( &clusterID, uint16 );
#endif
//		DBG( "clusterID = %04x", clusterID );
		pRead += 2; 	// pRead now point to the data

		if( profileID ) {
			// zcl
			pFrame.reset( new ZclFrame );
			if( !(pFrame.get()) )
				return -1;
			buildZclFrame( *pFrame, pRead, ptr );
            pFrame->setAddr( addr.addrData.shortAddr ); //!! only support short addr
            pFrame->setProfile( profileID );
            pFrame->setCluster( clusterID );
            pFrame->setSrcEp( srcep );
            pFrame->setDstEp( dstep );
#ifdef _DEBUG
			DBG2( "%s", pFrame->toString() );
#endif			
		} else {	// zdp 
			DBG( "ZDP Frame has not been implemented." );
		} // if profileID
	} else {
		DBG( "cmd type isn't API_RAW" );
		return 4;
	}


//#ifdef _DEBUG
//	DBG( "List size of genCbTmpList = %u", genCbTmpList.size() );
//	if( genCbTmpList.size() )
//		DBG( "%s", (*genCbTmpList.begin())->toString() );
//	DBG( "List size of broadcastCbList = %u", broadcastCbList.size() );
//	if( broadcastCbList.size() )
//		DBG( "%s", (*broadcastCbList.begin())->toString() );	
//#endif			
	
	/* find cb in all lists */
	// first in tmp list
	cmpMethod = (ZigbeeCmpType_t)(CMPBYALL & ~CMPBYCMD);
	pcb = genCbTmpList.find_remove( GeneralCallbackCmp(cmpMethod, &addr, profileID, 
			clusterID, srcep, dstep, pFrame->seqNO()) );
#ifdef _DEBUG
	if( pcb.get() )
		DBG( "found callback in genCbTmpList" );
#endif
	
	// then in broadcast list
	if( !pcb.get() ) {		
		cmpMethod = (ZigbeeCmpType_t)( CMPBYPROFILE | CMPBYCLUSTER | CMPBYDSTEP | CMPBYSEQNO | CMPBYCMD );		
		pcb = broadcastCbList.find_remove( GeneralCallbackCmp(cmpMethod, NULL, profileID, 
			clusterID, 0, dstep, pFrame->seqNO(), pFrame->cmd()) );
#ifdef _DEBUG
	if( pcb.get() )
		DBG( "found callback in broadcastCbList" );
#endif
	} // if !pcb

	// then in genCbList
	if( !pcb.get() ) {
		cmpMethod = (ZigbeeCmpType_t)( CMPBYPROFILE | CMPBYCLUSTER | CMPBYCMD );
		pcb = genCbList.find( GeneralCallbackCmp(cmpMethod, NULL, profileID, clusterID, 0, 0, 0, pFrame->cmd()) );
#ifdef _DEBUG
		if( pcb.get() )
			DBG( "found callback in genCbList" );
#endif
	} // if !pcb

	
	// not found
	if( !pcb.get() ) {
		DBG( "No callback processor found." );
		return -1;
	} else {
		CallbackProcessorFunc processor = pcb->routinePtr();
		if( processor )
			ret = processor( pFrame.release(), pcb.get() );
	}
	
	return ret;
}

static
void* working_routine( void *arg )
{
	char *word;

	DBG( "working_routine: thread_id = %lu", pthread_self() );

	while( running ) {
		word = read_a_word( zigbee_fd, 0x02 );
		if( !word ) {
			DBG( "working_routine read error." );
			continue;
		}
		if( (char*)0x02 == word )
			parseGenRsp();
		else
			parseAtCmdRsp( word );
	} // while
	
	return 0;
}

//static inline
//int getDeviceList()
//{
//	return zigbee_at_cmd( API_ATCMD, NULL, "atdump 2", ZIGBEE_TIMEOUT );
//}

static
int getDeviceInfo()
{
	int ret;
	void *vptr = 0;

	// timeout = 3s
	ret = zigbee_at_cmd( API_ATCMD, NULL, "atinfo", 3, &vptr );
	if( ret ) return ret;
	ZigbeeDevice *pDev = (ZigbeeDevice*)vptr;

//	DBG( "getDeviceInfo called." );
	if( pDev ) {
//		thisDev = *pDev;
		thisDev.reset( pDev );
//#ifdef _DEBUG
//		pDev->printThisDevice();
//#endif
	} else {
		DBG( "get device info null ptr" );
		return -1;
	}

	return 0;
}


void zigbee_register_event_callback( ZigbeeEventCallback callbackFunc )
{
    eventHandler = callbackFunc;
}

int zigbee_update_dev_list( bool clearOpt )
{
	static const int		tryCount = 3;
	Address_t		addr;
    const uint16   	addrData = 0xFFFF;
	ZclFrame		reqFrame;
	uint16			attrID;
	Callback		*cb;
	int				i, ret, retval = 0;

	ZigbeeCmpType_t method = (ZigbeeCmpType_t)( CMPBYPROFILE | CMPBYCLUSTER | CMPBYDSTEP | CMPBYSEQNO | CMPBYCMD );

#ifdef _DEBUG
	time_t now = time( NULL );
	DBG( "zigbee_update_dev_list() clearOpt = %s called at %s", clearOpt ? "true" : "false", ctime(&now) );
#endif

//	updateRecord.clear();
	zigbeeDevCandListForUpdate.clear();

	make_address( &addr, SHORT, &addrData );

	reqFrame.setCmd( (uint8)ZclBase::CMD_READ_ATTR ); 
	reqFrame.setSeqNO( SEQNO_UPDATE_DEV_LIST );
	attrID = ZclGenBasic::MANUNAME;
#ifdef HOST_ZCL_ENDIAN_DIFF
    BYTESWAP( &attrID, uint16 );
#endif
	reqFrame.appendPayload( &attrID, 2 );
	attrID = ZclGenBasic::MODELID;
#ifdef HOST_ZCL_ENDIAN_DIFF
	BYTESWAP( &attrID, uint16 );
#endif
	reqFrame.appendPayload( &attrID, 2 );

//#ifdef _DEBUG
//	{
//	int index = 0;
//	DBG( "broadcastCbList size = %u", broadcastCbList.size() );
//	for( GeneralCallbackSafeList::iterator it = broadcastCbList.begin(); it != broadcastCbList.end(); ++it )
//		DBG( "broadcast cb %d:\n%s", ++index, (*it)->toString() );
//	}
//#endif

	while( broadcastCbList.find_remove( GeneralCallbackCmp(method, NULL, thisDev->profileId(), 
						ZCL_CLUSTER_ID_GEN_BASIC, 0, thisDev->endpoint(), reqFrame.seqNO(), (uint8)ZclBase::CB_READ_ATTR)).get() );

	if( clearOpt )	
		zigbeeDevList.clear();

	// request for 3 times
	for( i = 0; i < tryCount; ++i ) {
		ret = zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0xFF, thisDev->profileId(),
						 ZCL_CLUSTER_ID_GEN_BASIC, &reqFrame,
						 0, NULL, NULL, parseUpdateDevList, ZclBase::CB_READ_ATTR );
		if( ret ) retval = ret;
		usleep(400*1000);
	} // for

	return retval;
//	return zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0xFF, thisDev->profileId(),
//					 ZCL_CLUSTER_ID_GEN_BASIC, &reqFrame,
//					 0, NULL, NULL, parseUpdateDevList, ZclBase::CB_READ_ATTR );
}


void zigbee_get_dev_list( std::vector<ZigbeeDevicePtr> &devlist )
{
#ifdef _DEBUG
	time_t now = time( NULL );
	DBG( "zigbee_get_dev_list() called at %s", ctime(&now) );
	printDevList();
#endif
	zigbeeDevList.getCopy( devlist );
	DBG( "zigbee_get_dev_list() result list size = %u", devlist.size() );
}


void zigbee_remove_dev( const ZigbeeDevicePtr pDev )
{
 	ZDevFinder_t		finder = (ZDevFinder_t)( ZDEV_FIND_BY_ADDR | ZDEV_FIND_BY_PROFILE | ZDEV_FIND_BY_ENDPOINT | ZDEV_FIND_BY_NAME );	

	ZigbeeDevicePtr pRemoved = zigbeeDevList.find_remove( ZDevCmp(finder, pDev->addr(), NULL, 
					pDev->name(), pDev->profileId(), pDev->endpoint()) );

	delete pRemoved;
}




int zigbee_init( char *dev_name, int baudrate, int flow_ctrl, 
			int databits, int stopbits, int parity )
{
	int fd, ret, i;

	DBG_INIT();
	
	DBG( "ZigWay SDK: %s", ZIGBEE_VERSION );
	DBG( "zigbee_init %s", dev_name );

	fd = OpenSerial(fd, dev_name);
	if( fd < 0 ) {
		ret = fd;
		DBG( "Cannot open device %s", dev_name );
		perror( "Open device fail." );
		goto FAIL;
	}

	ret = InitSerial(fd, baudrate, flow_ctrl, databits, stopbits, parity);
	if( ret ) {
		DBG( "InitSerial fail." );
		perror( "InitSerial error!" );
		goto FAIL;
	}

	zigbee_fd = fd;
	
	//!! old way of at cmd test can be added here

//	zigbee_at_cmd( API_ATCMD, NULL, "atieee 35de" );

//	DBG( "Reading all..." );
//	read_all_ascii(fd);

	// end of old test
	
	/* init global table and list for at command and general commands */
	// at commands
	atCmdCallbackTable.clear();
	atCmdCallbackTable["atinfo"].reset( new AtCmdCallback( "EINFO", parseAtInfo, 1 ) );
	atCmdCallbackTable["atieee"].reset( new AtCmdCallback( "EREPOIEEE", parseAtIeee, 0 ) );
//	atCmdCallbackTable["atdump"] = new AtCmdCallback( "Neighbor:", parseAtDump, 1 );
	atCmdSyncCallbackPtr.reset();

	atCmdCallbackList.clear();
	atCmdCallbackList.push_back( AtCmdCallbackPtr(new AtCmdCallback("EJOINED", parseNewJoin )) );

	
	// general cmd list both pernament and tmp
	genCbList.clear();
	genCbTmpList.clear();

	/* here we must specify profileid, clusterid, and cmdid */
	// for dealing with auto reporting
	genCbList.add( GeneralCallbackPtr(new GeneralCallback(NULL, ZCL_HA_PROFILE_ID, ZCL_CLUSTER_ID_GEN_BASIC, 0x0, 0x0, 0x0, 
						handleAutoReport, 0, 0x0a)) );
	// for dealing with alarm
	genCbList.add( GeneralCallbackPtr(new GeneralCallback(NULL, ZCL_HA_PROFILE_ID, ZCL_CLUSTER_ID_GEN_ALARMS, 0x0, 0x0, 0x0, 
						handleAlarm, 0, 0x0)) );

	// init device list
	zigbeeDevList.clear();
	zigbeeDevCandListForNewJoin.clear();
	zigbeeDevCandListForUpdate.clear();	

	// create and run reading thread
	running = 1;
	ret = pthread_create( &routine_tid, NULL, working_routine, NULL );
	if( ret ) {
		DBG( "start thread error: %s", strerror(ret) );
		goto FAIL;
	}

	DBG( "working_routine started. thread id = %lu", pthread_self() );

	for( i = 0; i < 5; ++i ) {
		ret = getDeviceInfo();
		if( !ret )
			break;
	} // for
	
	if( i >= 5 ) {
		DBG( "getDeviceInfo error, %d", ret );
		goto FAIL;
	}

	DBG( "ZigWay Device Info:" );
	DBG( "Address:\t\t\t%04x", thisDev->addr() );
	DBG( "ProfileID:\t\t\t%04x", thisDev->profileId() );
	DBG( "EndPoint:\t\t\t%02x", thisDev->endpoint() );
	DBG( "PanID:\t\t\t%04x", thisDev->panId() );
	DBG( "Channel:\t\t\t%d", thisDev->channel() );

//	ret = getDeviceList();
//	if( ret ) {
//		DBG( "getDeviceList error, %d", ret );
//		goto FAIL;
//	}
//#ifdef _DEBUG
//	printDevList();
//#endif	
	
	return 0;
FAIL:
	DBG( "zigbee init fail, retcode = %d", ret );
	if( routine_tid ) {
		zigbee_finalize();
	} else {
		atCmdSyncCallbackPtr.reset();
		running = 0;
		thisDev.reset(0);
		close( fd );
	}	
	return ret;
}

int zigbee_finalize()
{
	using namespace std;
	
	DBG( "zigbee_finalize" );

	running = 0;

	// issue a comand to generate feedback output in order to prevent working routine blocked in read
	zigbee_at_cmd( API_ATCMD, NULL, "atinfo" );
	pthread_join( routine_tid, NULL );
	DBG( "working routine terminated." );
	routine_tid = 0;
	
	close( zigbee_fd );

	/* delete all structures */
	// atCmdCallbackTable
//	DBG( "clear atCmdCallbackTable & atCmdCallbackList" );
	atCmdSyncCallbackPtr.reset();
//	for( AtCmdCallbackTable::iterator it = atCmdCallbackTable.begin(); 
//			it != atCmdCallbackTable.end(); ++it ) {
//		CallbackPtr p = it->second;
//		delete p;
//	}
	atCmdCallbackTable.clear();
	atCmdCallbackList.clear();
//	DBG( "clear atCmdCallbackTable & atCmdCallbackList finish" );

	// general lists
	genCbTmpList.clear();
    genCbList.clear();
	broadcastCbList.clear();

	// clear device list
	zigbeeDevList.clear();
	// clear device cand list
	zigbeeDevCandListForNewJoin.clear();
	zigbeeDevCandListForUpdate.clear();	

	thisDev.reset(0);
	
	return 0;
}

//static
//int Memcpy( uint8 **buf, uint8 **ptr, int *bufLen,
//			  void *data, int dataLen, float ratio )
//{
//	int offset = *ptr - *buf;

//	if( offset + dataLen > *bufLen ) {
////		DBG( "realloc" );
//		*bufLen = ratio * (offset + dataLen);
//		*buf = (uint8*)realloc( *buf, *bufLen );
//		if( !(*buf) )
//			return -1;
//		*ptr = *buf + offset;
//	} // if

//	memcpy( *ptr, data, dataLen );
//	*ptr += dataLen;

//	return 0;
//}


//void make_address( Address_t *addr, AddrType_t addrType, ... )
//{
//	va_list ap;
//	void*	pLongAddr;

//	memset( addr, 0, sizeof(*addr) );
//	addr->type = addrType;
//	if( NOTPRESENT == addrType )
//		return;

//	va_start( ap, addrType );
//	if( EXTENDED == addrType ) {
//		pLongAddr = va_arg( ap, void* );
//		memcpy( addr->addrData.ieeeAddr, pLongAddr, 8 );
//	} else {
//		addr->addrData.shortAddr = (uint16)va_arg( ap, int );
//	}
//	va_end(ap);

//	return;
//}

// dstAddr can be NULL refer to NOTPRESENT
static
int zigbee_send_data( CmdType_t cmdType, Address_t *dstAddress, const void *data, uint16 dataLen )
{
	int ret = 0;
	uint8 cmdId, *buf, *ptr;
	AddrType_t addrType;
	uint16 length;
	ssize_t n;

	DBG( "zigbee_send_data" );
//	pr_mem( data, dataLen );

	buf = (uint8*)malloc( dataLen + 14 );
	if( !buf ) {
		DBG( "memory allocation failed." );
		ret = -1;
		goto RET;
	}
	ptr = buf;

	*ptr = 0x02;	// start
	ptr += 3;		// skip length, compute it later
	// get cmdId
	addrType = dstAddress ? dstAddress->type : NOTPRESENT;
	cmdId = (uint8)( (uint8)addrType << 6 | (uint8)cmdType );
//	DBG( "CmdId = %02x", cmdId );
	*ptr++ = cmdId;
	// address
	switch( addrType ) {
	case NOTPRESENT:
		break;
	case EXTENDED:
		memcpy( ptr, dstAddress->addrData.ieeeAddr, 8 );
		ptr += 8;
		break;
	default:		// short addr
		{
		uint16 shortAddr = dstAddress->addrData.shortAddr;
#ifdef HOST_ZDEV_ENDIAN_DIFF
		BYTESWAP( &shortAddr, uint16 );
#endif
		memcpy( ptr, &shortAddr, 2 );
		ptr += 2;
		}
	} // switch 
	// data
	memcpy( ptr, data, dataLen );
	ptr += dataLen;
	// compute length
	length = (uint16)(ptr - buf - 3);
#ifdef HOST_ZDEV_ENDIAN_DIFF
	BYTESWAP( &length, uint16 );
#endif
	memcpy( buf+1, &length, 2 );
	// checksum
	*ptr = get_checksum( buf + 1, ptr );		// checksum
	*++ptr = 0x03;		// end
	++ptr;

	// write to device
	n = (ssize_t)(ptr - buf);
	pr_mem( buf, n );
	if( writen( zigbee_fd, buf, n ) != n ) {
		DBG( "write device error, %d", errno );
		ret = -1;
		goto RET;
	}

RET:
	free(buf);
	DBG( "zigbee_send_data finish retcode = %d", ret );
	return ret;
}

int zigbee_at_cmd( CmdType_t cmdType, Address_t *dstAddress, 
		const char *cmdString, int timeout, void **result, uint16 *resultLen )
{
	int 		ret = 0;
	const char	*ptr;
	uint16		cbDataLen;
	
	using namespace std;

	DBG( "zigbee_at_cmd: %s, timeout=%d", cmdString, timeout );

	ptr = strpbrk( cmdString, " \t\f\r\v\n" );
	if( !ptr ) ptr = cmdString + strlen(cmdString);

	AtCmdCallbackTable::iterator it = atCmdCallbackTable.find( string(cmdString, ptr) );
	if( atCmdCallbackTable.end() != it ) {
		atCmdSyncCallbackPtr = it->second;
	} else {
		atCmdSyncCallbackPtr.reset();
		DBG( "Command %s has no processor.", cmdString );
	}

//#ifdef _DEBUG
//	if( atCmdSyncCallbackPtr )
//		DBG( "zigbee_at_cmd atCmdSyncCallbackPtr->NAME is %s", atCmdSyncCallbackPtr->name() );
//	else		
//		DBG( "atCmdSyncCallbackPtr is NULL" );
//#endif
	ret = zigbee_send_data(cmdType, dstAddress, cmdString, strlen(cmdString) );
	if( ret ) {
		DBG( "zigbee_send_data error: %d", ret );
		goto RET;
	}

	// wait for finish
	if( timeout && atCmdSyncCallbackPtr.get() ) {
		DBG( "Wait for finish %s.", atCmdSyncCallbackPtr->name() );
		ret = atCmdSyncCallbackPtr->wait( timeout );
		if( ret ) {
#ifdef _DEBUG			
			if( ETIMEDOUT == errno )
				DBG( "zigbee_at_cmd wait timeout." );
			else
				DBG( "zigbee_at_cmd wait error, %d", ret );
#endif			
			goto RET;
		} else {
			// on success, feedback the data
			DBG( "%s return success.", atCmdSyncCallbackPtr->name() );
			if( result )
				cbDataLen = atCmdSyncCallbackPtr->getCbData( *result );			
			if( resultLen )
				*resultLen = cbDataLen;
		} // if ret
	} // if

	
RET:
//	atCmdSyncCallbackPtr = 0;
	DBG( "zigbee_at_cmd finish retcode = %d", ret );
	return ret;
}

// write zcl frame to buf, which is pre-allocated by the caller
// return the length of the zcl frame on success
static
int writeZcl2Buf( uint8 control, uint8 cmd, const void *payload, 
		uint16 payloadLen, void *buf, uint8 seqNO, uint16 manufacturerCode )
{
	uint8 *ptr = (uint8*)buf;

	*ptr++ = control;
	// manufacturerCode
	if( control & ZCL_FRAME_MANU_SPEC ) {
#ifdef HOST_ZCL_ENDIAN_DIFF
		BYTESWAP( &manufacturerCode, uint16 );
#endif
		memcpy( ptr, &manufacturerCode, 2 );
		ptr += 2;
	} // if
	*ptr++ = seqNO;
	*ptr++ = cmd;
	// payload can be NULL
	if( payload ) {
		memcpy( ptr, payload, payloadLen );
		ptr += payloadLen;
	}
			
	return (int)( ptr - (uint8*)buf );
}


// sending general frame that containing profileID, clusterID and endpoints
// zcl and zdp
static
int general_request( Address_t *dstAddress, uint8 srcep, uint8 dstep, 
		uint16 profileID, uint16 clusterID, void *data, uint16 dataLen )
{
	int ret = 0;
	uint8 *buf, *ptr;

//	DBG( "general_request" );
//	pr_mem( zclData, dataLen );

	buf = (uint8*)malloc( dataLen + 6 );
	if( !buf ) {
		DBG( "memory allocation failed." );
		ret = -1;
		goto RET;
	}
	ptr = buf;

	// endpoints
	*ptr++ = srcep;
	*ptr++ = dstep;
	// profile and cluster IDs
#ifdef HOST_ZDEV_ENDIAN_DIFF
	BYTESWAP( &profileID, uint16 );
	BYTESWAP( &clusterID, uint16 );
#endif	
	memcpy( ptr, &profileID, 2 );
	ptr += 2;
	memcpy( ptr, &clusterID, 2 );
	ptr += 2;
	memcpy( ptr, data, dataLen );
	ptr += dataLen;			// data

	ret = zigbee_send_data( API_RAW, dstAddress, buf, dataLen + 6 );
	if( ret ) {
		DBG( "zigbee_send_data fail: %d", ret );
		goto RET;
	}

RET:	
	free( buf );
//	DBG( "general_request send data %s.", ret ? "fail" : "success" );
	return ret;
}


static
int zigbee_zcl_cmd_helper( Address_t *dstAddress, uint8 srcep, uint8 dstep, 
		uint16 profileID, uint16 clusterID, uint8 zclControl, uint8 zclCmd, 
		uint8 zclSeqNO, const void *zclPayload, uint16 zclPayloadLen, 
		int timeout, void **result, uint16 *resultLen,
		CallbackProcessorFunc cbProcessor,
		uint16 zclManufacturerCode, uint8 cmdID )
{
	uint8						*buf;
	int							ret = 0;
	int							zclFrameLen;
	GeneralCallbackPtr			pcb;
	uint16						cbDataLen;
	CallbackProcessorFunc 		processorFunc;
	bool						isBroadcast = false;

	using namespace std;

	if( timeout )
		zclControl &= ~ZCL_FRAME_NO_RSP;

	DBG( "zigbee_zcl_cmd, zcl frame is:" );

	buf = (uint8*)malloc( zclPayloadLen + 5 );
	if( !buf )
		goto FAIL;

	zclFrameLen = writeZcl2Buf( zclControl, zclCmd, zclPayload, zclPayloadLen, 
		buf, zclSeqNO, zclManufacturerCode );

	pr_mem( buf, zclFrameLen );

	DBG( "timeout = %d", timeout );

	// register callback
	//!! callback dstep is that of the device itself, srcep is that of the remote dev
//	if( cbProcessor == NULL )
//		DBG( "cbProcessor == NULL" );
//	else
//		DBG( "cbProcessor != NULL" );
	processorFunc = cbProcessor ? cbProcessor : parseZclCB;
	pcb.reset( new GeneralCallback( dstAddress, profileID, 
			clusterID, dstep, srcep, zclSeqNO, processorFunc, timeout != 0, cmdID ) );
	if( !pcb.get() ) goto FAIL;

	if( dstAddress->type == SHORT && 0xFFFF == dstAddress->addrData.shortAddr )
		isBroadcast = true;

	if( isBroadcast) {
//		DBG( "Add cb to broadcastCbList" );
		broadcastCbList.add( pcb );
	} else {
//		DBG( "Add cb to genCbTmpList" );
		genCbTmpList.add( pcb );
	}

	ret = general_request( dstAddress, srcep, dstep, profileID, clusterID, buf, zclFrameLen );
	if( ret ) {
		DBG( "general_request error. %d", ret );
		goto FAIL;
	}
	
	if( timeout ) {
		// wait for finish
		ret = pcb->wait( timeout );
		if( ret ) {
			if( ETIMEDOUT == errno ) {
				DBG( "zigbee_zcl_cmd wait timeout" );
				//!! maybe working thread running in "finish"
				pcb->finish( Callback::FAIL, -1 );
			}
			DBG( "zcl request error, %d", ret );
			goto FAIL;
		} // if ret

		// success return, it's the caller's duty to delete
		DBG ( "zigbee_zcl_cmd success." );
		if( result )
			cbDataLen = pcb->getCbData( *result );		
		if( resultLen )
			*resultLen = cbDataLen;

//		delete pcb;
	} // if  timeout
	
RET:
	free(buf);
	return ret;
FAIL:
	DBG( "zigbee_zcl_cmd fail: %s", strerror(errno) );
	
	free(buf);
	if( pcb.get() ) {
		if( isBroadcast ) {
			broadcastCbList.find_remove( bind2nd(equal_to<GeneralCallbackPtr>(), pcb) );
		} else { 
			genCbTmpList.find_remove( bind2nd(equal_to<GeneralCallbackPtr>(), pcb) );
		}
//		delete pcb;
	}
	
	return -1;
}


int zigbee_zcl_cmd( Address_t *dstAddress, uint8 srcep, uint8 dstep, 
		uint16 profileID, uint16 clusterID, const ZclFrame *pZclFrame, 
		int timeout, void **result, uint16 *resultLen,
		CallbackProcessorFunc cbProcessor, uint8 cmdID )
{
	uint16			manuCode;
	
	if( !pZclFrame )
		return 1;
	if( pZclFrame->isManuSpec() )
		manuCode = pZclFrame->manuCode();
	return zigbee_zcl_cmd_helper( dstAddress, srcep, dstep, profileID, clusterID, 
				pZclFrame->frameCtrl(), pZclFrame->cmd(), pZclFrame->seqNO(), pZclFrame->payload(), 
				pZclFrame->payloadLen(), timeout, result, resultLen, cbProcessor, manuCode, cmdID );
}




#ifdef _DEBUG


static
void atInfoTest()
{
	for( int i = 0; i < 10; ++i ) {
		DBG( "atInfoTest for the %d time.", i+1 );
		getDeviceInfo();
	}
}


static
void configReportTest( uint16 addrData )
{
	uint16			attrID = 0x0005;
	Address_t		addr;
//	uint16			addrData = 0x0e6d;
//	uint16			addrData = 0x1901;


	ZclFrame reqFrame;
	reqFrame.setSeqNO( 0xAB );
	reqFrame.setCmd( 0x06 );

	//reqFrame.appendPayload( 0x00 );		// direction
	reqFrame.appendPayload( 0x01 );		// direction
	reqFrame.appendPayload( &attrID, 2 );
	//reqFrame.appendPayload( ZCL_DATATYPE_CHAR_STR );
	//reqFrame.appendPayload( 0x0 );
	//reqFrame.appendPayload( 0x0 );		// min interval
	//reqFrame.appendPayload( 0xFF );
	//reqFrame.appendPayload( 0xFF );		// max interval
	//reqFrame.appendPayload( 0x1e );//per 30sec report
	reqFrame.appendPayload( 0x0 );
	reqFrame.appendPayload( 0x0 );		// timeout

	make_address( &addr, SHORT, &addrData );

	// no timeout
    zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0x0, ZCL_HA_PROFILE_ID, ZCL_CLUSTER_ID_GEN_BASIC,
                         &reqFrame, 0 );
}



static
void readAttrTest( uint16 addrData, uint16 clusterID, uint16 attrID )
{
	Address_t		addr;

	ZclFrame reqFrame;
	reqFrame.setSeqNO( 0xAB );
	reqFrame.setCmd( 0x00 );
	
	reqFrame.appendPayload( &attrID, 2 );

	make_address( &addr, SHORT, &addrData );

	// no timeout
    zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0x0, ZCL_HA_PROFILE_ID, 0x0002,
                         &reqFrame, 0 );
}

static
void writeAttrTest( uint16 addrData, uint16 clusterID, uint16 attrID, uint8 dataType, void *attrVal, uint16 len = 0 )
{
	Address_t		addr;

	ZclFrame reqFrame;
	reqFrame.setSeqNO( 0xAC );
	reqFrame.setCmd( 0x02 );
	
	reqFrame.appendPayload( &attrID, 2 );
	reqFrame.appendPayload( dataType );
	reqFrame.appendPayload( attrVal, zclDataTypeLen(dataType) );	

	make_address( &addr, SHORT, &addrData );

	// no timeout
    zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0x0, ZCL_HA_PROFILE_ID, 0x0002,
                         &reqFrame, 0 );
}

static
void zclCmdTest( uint16 addrData, uint16 clusterID, uint8 cmdID, void *arg, uint16 arglen  )
{
	ZigbeeDevice dev;
	dev.setAddr( addrData );
	ZclBase::issueZclCmd( dev, clusterID, cmdID, arg, arglen, 0 );
}

static
void discoverAttrTest( uint16 addrData, uint16 clusterID )
{
	Address_t		addr;
	ZclFrame 		reqFrame;

	make_address( &addr, SHORT, &addrData );

	reqFrame.setSeqNO( 0xAB );
	reqFrame.setCmd( 0x0c );
	reqFrame.appendPayload( 0x00 );
	reqFrame.appendPayload( 0x00 ); // start attr
	reqFrame.appendPayload( 0xFF );	// len

	// no timeout
    zigbee_zcl_cmd( &addr, thisDev->endpoint(), 0x0, ZCL_HA_PROFILE_ID, clusterID,
                         &reqFrame, 0 );
}

// testing
void testUtil()
{
	int			i;
	
	WAIT( "testUtil..........." );

//	configReportTest(0x1901);
//	sleep(1);
//	configReportTest(0x0e6d);

//	discoverAttrTest( 0x1901, ZCL_CLUSTER_ID_UBEC_POWERMETER );
//	sleep(1);
//	discoverAttrTest( 0x1901, ZCL_CLUSTER_ID_UBEC_POWERMETER );
//	discoverAttrTest( 0x1901, ZCL_CLUSTER_ID_GEN_ON_OFF );

	{
		uint32 data;
//		data = 0x0A;
//		writeAttrTest( 0x0e6d, 0x0002, 0x0014, ZCL_DATATYPE_UINT24, &data );
		// set low bound
//		data = 0x0DAC;
//		writeAttrTest( 0x0e6d, 0x0002, 0x0011, ZCL_DATATYPE_DATA16, &data );
//		sleep(1);
//		// set high bound
//		data = 0x0FA0;
//		writeAttrTest( 0x0e6d, 0x0002, 0x0012, ZCL_DATATYPE_DATA16, &data );
//		sleep(1);

//		data = 0x0A;
//		writeAttrTest( 0x0e6d, 0x0002, 0x0013, ZCL_DATATYPE_UINT24, &data );
//		sleep(1);

		// reset alarm
//		uint8 arr[] = { 0x02, 0x02, 0x00 };
//		zclCmdTest( 0x0e6d, 0x0009, 0x0, arr, sizeof(arr) );
//		sleep(1);
//		readAttrTest( 0x0e6d, 0x0002, 0x0013 );
//		readAttrTest( 0x0e6d, 0x0002, 0x0014 );
//		sleep(1);
		readAttrTest( 0x0e6d, 0x0002, 0x0010 );
//		sleep(1);
//		readAttrTest( 0x0e6d, 0x0002, 0x0012 );
	}
//	writeAttrTest();

//	atInfoTest();
//	switchTest();

	// see zcl spec table 3.8
//	for( i = 0; i < 8; ++i )		
//		readAttrTest(i);

//	devTest();

}


#endif	//_DEBUG








